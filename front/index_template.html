<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

    <title>Domus Quietus Domus</title>
    <link rel="stylesheet" href="assets/normalize.css">
    <link rel="stylesheet" href="assets/$style">
    <link rel="stylesheet" href="assets/autocomplete.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans+Extra+Condensed&display=swap" rel="stylesheet">
</head>
<body>
<div id="navbar">
    <div id="search">
        <img id="search-icon" src="assets/search.svg" alt="Recherche">
        <input id="search-input" type="text" placeholder="Recherche" autocomplete="false">
    </div>
    <div id="search-filters"></div>
</div>
<div id="content">
    <picture>
        <source srcset="assets/palais.webp" type="image/webp">
        <img src="assets/palais.jpg" alt="Palais" style="width: 100%; margin-bottom: 20px;"/>
    </picture>
    <div id="quotes-list">
        $content
    </div>
    $footer
</div>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.basic.min.js"></script>
<script>
    let tag_filters = [];

    function sh(id) {
        navigator.share({url: 'https://domusquietusdomus.com/quotes/' + id + '.html'});
    }

    function normalize(str) {
        return str.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    let quoteNodes = Array.from(document.querySelectorAll('.quote'));
    let quotesData = quoteNodes.map(quote => {
        let title = quote.querySelector('.quote-title')?.innerText || '';
        let tags = Array.from(quote.querySelectorAll('.quote-tag')).map(t => t.innerText.trim());

        return {
            node: quote,
            title,
            tags,
            searchText: normalize(title + ' ' + tags.join(' '))
        };
    });

    let allUniqueTags = [];
    quotesData.forEach(quote => {
        quote.tags.forEach(tag => {
            if (!allUniqueTags.some(t => normalize(t) === normalize(tag))) {
                allUniqueTags.push(tag);
            }
        });
    });

    let tags = allUniqueTags.map(tag => ({
        name: tag,
        type: "Tag",
        name_norm: normalize(tag)
    }));

    let fuseQuotes = new Fuse(quotesData, {
        keys: ['title', 'tags', 'searchText'],
        threshold: 0.3,
        ignoreLocation: true,
        minMatchCharLength: 2
    });

    function filterQuotes() {
        let search = normalize(document.getElementById('search-input').value.trim());
        let filtered = quotesData;

        if (search.length > 0) {
            filtered = fuseQuotes.search(search).map(result => result.item);
        }

        if (tag_filters.length > 0) {
            filtered = filtered.filter(quote =>
                tag_filters.every(tag =>
                    quote.tags.some(t => normalize(t) === normalize(tag))
                )
            );
        }

        quotesData.forEach(quote => {
            quote.node.style.display = filtered.includes(quote) ? '' : 'none';
        });
    }

    document.getElementById('search-input').addEventListener('input', filterQuotes);

    function renderFilters() {
        let filters = document.getElementById("search-filters");
        filters.innerHTML = "";
        for (let tag of tag_filters) {
            let tagEl = document.createElement("div");
            tagEl.classList.add("search-filter");
            tagEl.textContent = "Ã— " + tag;
            tagEl.addEventListener("click", () => {
                tag_filters = tag_filters.filter((t) => t !== tag);
                renderFilters();
                filterQuotes();
            });
            filters.appendChild(tagEl);
        }
    }

    let fuse = new Fuse(tags, {
        keys: ['name_norm'],
        includeScore: true,
        includeMatches: true,
        threshold: 0.3
    });

    let inp = document.getElementById("search-input");

    inp.addEventListener("focus", function() {
        if (inp.value.trim() === "") {
            this.dispatchEvent(new Event('input'));
        }
    });

    autocomplete(inp, async (search) => {
        if (search === "") {
            return [
                allUniqueTags,
                allUniqueTags.map(() => "Tag"),
                allUniqueTags.map(() => [])
            ];
        }

        let res = fuse.search(normalize(search));

        let arr = res.map((r) => r.item.name);
        let data = res.map((r) => r.item.type);

        let poses = res.map((r) => {
            let pos = [];

            for (let idx of r.matches[0].indices) {
                for (let i = idx[0]; i <= idx[1]; i++) {
                    pos.push(i);
                }
            }

            return pos;
        });

        return [arr, data, poses];
    }, (val, _) => {
        inp.value = "";
        if (!tag_filters.includes(val)) tag_filters.push(val);
        renderFilters();
        filterQuotes();
    }, () => {});

    function autocomplete(inp, onInput, onSubmit, onSubmitEmpty) {
        let currentFocus;
        let syncId = 0;
        inp.addEventListener("input", function () {
            let a, b, i, val = this.value;
            syncId += 1;
            let syncCpy = syncId;
            onInput(val).then((res) => {
                if (syncCpy !== syncId) {
                    return;
                }
                closeAllLists();
                a = document.createElement("DIV");
                a.setAttribute("id", this.id + "autocomplete-list");
                a.setAttribute("class", "autocomplete-items");
                this.parentNode.appendChild(a);
                let [arr, data, poses] = res;
                for (i = 0; i < arr.length; i++) {
                    let val = arr[i];
                    let d = data[i];
                    let pos = poses[i];
                    b = document.createElement("DIV");

                    let renderedVal = "";
                    if (pos.length > 0) {
                        // Highlight matched parts
                        let j2 = 0;
                        for (let j = 0; j < val.length; j++) {
                            while (j2 < pos.length && pos[j2] < j) j2++;
                            if (j2 < pos.length && pos[j2] === j) {
                                renderedVal += `<b>${val[j]}</b>`;
                            } else {
                                renderedVal += val[j];
                            }
                        }
                    } else {
                        // No highlighting needed for empty search
                        renderedVal = val;
                    }

                    b.innerHTML = `<span>${renderedVal}</span><span class="autocomplete-data">${d}</span>`;
                    b.style.display = "flex";
                    b.style.justifyContent = "space-between";
                    b.addEventListener("click", function () {
                        onSubmit(val, d);
                        closeAllLists();
                    });
                    a.appendChild(b);
                }
            }).catch(() => {
                closeAllLists()
            })
        });

        inp.addEventListener("keydown", function (e) {
            let x = document.getElementById(this.id + "autocomplete-list");
            if (x) x = x.getElementsByTagName("div");
            if (e.keyCode === 40) { // DOWN
                currentFocus++;
                addActive(x);
            } else if (e.keyCode === 38) { // UP
                currentFocus--;
                addActive(x);
            } else if (e.keyCode === 13) { // ENTER
                e.preventDefault();
                if (currentFocus > -1) {
                    if (x) x[currentFocus].click();
                } else {
                    onSubmitEmpty();
                }
            }
        });

        function addActive(x) {
            if (!x) return false;
            removeActive(x);
            if (currentFocus >= x.length) currentFocus = 0;
            if (currentFocus < 0) currentFocus = (x.length - 1);
            x[currentFocus].classList.add("autocomplete-active");
        }

        function removeActive(x) {
            for (let i = 0; i < x.length; i++) {
                x[i].classList.remove("autocomplete-active");
            }
        }

        function closeAllLists(elmnt) {
            currentFocus = -1;
            let x = document.getElementsByClassName("autocomplete-items");
            for (let i = 0; i < x.length; i++) {
                if (elmnt !== x[i] && elmnt !== inp) {
                    x[i].parentNode.removeChild(x[i]);
                }
            }
        }

        document.addEventListener("click", function (e) {
            closeAllLists(e.target);
        });
    }

    for (let quote of document.querySelectorAll('.quote')) {
        quote.addEventListener('click', () => {
            for (let open of document.getElementsByClassName('quote-selected')) {
                if (open === quote) {
                    continue;
                }
                open.classList.remove('quote-selected');
            }
            quote.classList.add('quote-selected');
        });
    }

    document.getElementById('search-icon').addEventListener('click', () => {
        document.getElementById('search-input').focus();
    });

    // Initialize filtering (in case there are URL params)
    filterQuotes();
</script>
</body>
</html>
